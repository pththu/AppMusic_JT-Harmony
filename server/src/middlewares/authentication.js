const jwt = require('jsonwebtoken');
const { User } = require('../models');
require('dotenv').config();

/**
 * Middleware x√°c th·ª±c token (JWT) t·ª´ Cookie ho·∫∑c Header Authorization.
 */
exports.authenticateToken = async(req, res, next) => {
    console.log("--- B·∫ÆT ƒê·∫¶U AUTHENTICATE ---");
    console.log("Raw Headers:", req.headers); // C√≥ th·ªÉ b·∫≠t l·∫°i log n√†y n·∫øu c·∫ßn debug s√¢u

    try {
        let token;

        // 1. L·∫•y token t·ª´ Cookie ('accessToken')
        token = req.cookies['accessToken'];

        // 2. N·∫øu kh√¥ng c√≥ trong cookie, l·∫•y t·ª´ Header 'Authorization'
        if (!token) {
            // Express th∆∞·ªùng chuy·ªÉn header v·ªÅ lowercase (authorization)
            let authHeader = req.headers['authorization'];

            // N·∫øu kh√¥ng c√≥ lowercase, th·ª≠ check v·ªõi t√™n header g·ªëc (Authorization)
            if (!authHeader) {
                authHeader = req.headers['Authorization'];
            }

            if (authHeader && authHeader.startsWith('Bearer ')) {
                token = authHeader.split(' ')[1];
            }
        }

        console.log("Token ƒë∆∞·ª£c t√¨m th·∫•y:", token ? "C√ì" : "KH√îNG");

        if (!token) {
            console.log("L·ªñI: Access token required (Token KH√îNG ƒë∆∞·ª£c t√¨m th·∫•y)");
            return res.status(401).json({ error: 'Access token required' });
        }

        // Verify token
        const decoded = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);

        // Check if user exists
        const user = await User.findByPk(decoded.id);
        if (!user) {
            console.log("L·ªñI: User not found (ID:", decoded.id, ")");
            return res.status(401).json({ error: 'User not found' });
        }

        // Th√™m th√¥ng tin User v√†o request ƒë·ªÉ c√°c middleware/controller sau s·ª≠ d·ª•ng
        req.user = decoded; // Th√¥ng tin t·ª´ token (id, role,...)
        req.currentUser = user; // To√†n b·ªô th√¥ng tin t·ª´ DB
        console.log("X√°c th·ª±c th√†nh c√¥ng cho User ID:", decoded.id);
        next();

    } catch (err) {
        if (err.name === 'TokenExpiredError') {
            console.log("L·ªñI AUTH: Token expired");
            return res.status(401).json({ error: 'Token expired' });
        }
        if (err.name === 'JsonWebTokenError') {
            console.log("L·ªñI AUTH: Invalid token");
            return res.status(401).json({ error: 'Invalid token' });
        }
        console.error('L·ªñI AUTH KH√îNG X√ÅC ƒê·ªäNH:', err.message);
        return res.status(500).json({ error: 'Internal server error: ' + err.message });
    }
};

exports.optionalAuthenticateToken = async(req, res, next) => {
    let token;

    // 1. L·∫•y token t·ª´ Cookie ('accessToken')
    token = req.cookies && req.cookies['accessToken'];

    // 2. N·∫øu kh√¥ng c√≥ trong cookie, l·∫•y t·ª´ Header 'Authorization' (logic robust)
    if (!token) {
        let authHeader = req.headers['authorization']; // Th·ª≠ lowercase tr∆∞·ªõc

        if (!authHeader) {
            authHeader = req.headers['Authorization']; // Th·ª≠ uppercase
        }

        if (authHeader && authHeader.startsWith('Bearer ')) {
            token = authHeader.split(' ')[1];
        }
    }

    // üéØ LOG M·ªöI: B√°o hi·ªáu k·∫øt qu·∫£ t√¨m ki·∫øm Token
    if (!token) {
        req.user = null;
        req.currentUser = null;
        // Case A: Kh√¥ng c√≥ token
        console.log("OPTIONAL AUTH: KH√îNG t√¨m th·∫•y Token. Ti·∫øp t·ª•c v·ªõi numericUserId: null.");
        return next();
    }

    // 3. C√ì token, B·∫Øt ƒë·∫ßu x√°c th·ª±c
    try {
        const decoded = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);

        const user = await User.findByPk(decoded.id, {
            attributes: ['id', 'username', 'roleId', 'fullName']
        });

        if (user) {
            // üéØ G√°n TH√ÄNH C√îNG: ƒê·∫£m b·∫£o ID l√† ki·ªÉu Number
            req.user = {
                id: Number(user.id), // √âp ki·ªÉu an to√†n
                username: user.username,
                roleId: user.roleId,
                fullName: user.fullName
            };
            req.currentUser = user;

            // Case B: Th√†nh c√¥ng
            console.log("OPTIONAL AUTH: Th√†nh c√¥ng, User ID ƒë∆∞·ª£c g√°n:", req.user.id);
        } else {
            // Case C: Token h·ª£p l·ªá nh∆∞ng user kh√¥ng t·ªìn t·∫°i trong DB
            console.warn("OPTIONAL AUTH: User t·ª´ token kh√¥ng t·ªìn t·∫°i. Ti·∫øp t·ª•c v·ªõi null.");
            req.user = null;
            req.currentUser = null;
        }

        return next();

    } catch (err) {
        // Case D: Token KH√îNG H·ª¢P L·ªÜ (h·∫øt h·∫°n, sai ch·ªØ k√Ω)
        console.warn(`OPTIONAL AUTH: Token KH√îNG H·ª¢P L·ªÜ (${err.name}). Ti·∫øp t·ª•c v·ªõi null.`);
        req.user = null;
        req.currentUser = null;
        return next();
    }
};

/**
 * Middleware ki·ªÉm tra vai tr√≤ ng∆∞·ªùi d√πng (ch·ªâ cho ph√©p Admin - roleId 1).
 */
exports.authorizeRole = (req, res, next) => {
    try {
        // req.currentUser ph·∫£i ƒë∆∞·ª£c thi·∫øt l·∫≠p b·ªüi authenticateToken tr∆∞·ªõc ƒë√≥
        const user = req.currentUser;

        if (!user) {
            // N·∫øu kh√¥ng c√≥ user (c√≥ th·ªÉ do qu√™n d√πng authenticateToken tr∆∞·ªõc ƒë√≥)
            return res.status(403).json({ error: 'Forbidden: User not authenticated' });
        }

        // Ki·ªÉm tra vai tr√≤ (gi·∫£ s·ª≠ roleId = 1 l√† Admin)
        if (user.roleId !== 1) {
            return res.status(403).json({ error: 'Unauthorized: Insufficient role permissions' });
        }

        next();
    } catch (error) {
        console.error('Authorization error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
};